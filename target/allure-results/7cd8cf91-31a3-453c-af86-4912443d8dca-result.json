{"name": "test_login[engribadkhan96@gmail.com-Engr@1122]", "status": "broken", "statusDetails": {"message": "urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=60095): Read timed out. (read timeout=120)", "trace": "self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001E782054E60>\nconn = <urllib3.connection.HTTPConnection object at 0x000001E781D384A0>\nmethod = 'POST', url = '/session'\ntimeout = Timeout(connect=120, read=120, total=None), chunked = False\nhttplib_request_kw = {'body': '{\"capabilities\": {\"firstMatch\": [{}], \"alwaysMatch\": {\"browserName\": \"firefox\", \"acceptInsecureCerts\": true,...on': 'keep-alive', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.28.1 (python windows)'}}\ntimeout_obj = Timeout(connect=120, read=120, total=None), read_timeout = 120\n\n    def _make_request(\n        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw\n    ):\n        \"\"\"\n        Perform a request on a given urllib connection object taken from our\n        pool.\n    \n        :param conn:\n            a connection from one of our connection pools\n    \n        :param timeout:\n            Socket timeout in seconds for the request. This can be a\n            float or integer, which will set the same timeout value for\n            the socket connect and the socket read, or an instance of\n            :class:`urllib3.util.Timeout`, which gives you more fine-grained\n            control over your timeouts.\n        \"\"\"\n        self.num_requests += 1\n    \n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\n    \n        # Trigger any extra validation we need to do.\n        try:\n            self._validate_conn(conn)\n        except (SocketTimeout, BaseSSLError) as e:\n            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n    \n        # conn.request() calls http.client.*.request, not the method in\n        # urllib3.request. It also calls makefile (recv) on the socket.\n        try:\n            if chunked:\n                conn.request_chunked(method, url, **httplib_request_kw)\n            else:\n                conn.request(method, url, **httplib_request_kw)\n    \n        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is\n        # legitimately able to close the connection after sending a valid response.\n        # With this behaviour, the received response is still readable.\n        except BrokenPipeError:\n            # Python 3\n            pass\n        except IOError as e:\n            # Python 2 and macOS/Linux\n            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE/ECONNRESET are needed on macOS\n            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/\n            if e.errno not in {\n                errno.EPIPE,\n                errno.ESHUTDOWN,\n                errno.EPROTOTYPE,\n                errno.ECONNRESET,\n            }:\n                raise\n    \n        # Reset the timeout for the recv() on the socket\n        read_timeout = timeout_obj.read_timeout\n    \n        # App Engine doesn't have a sock attr\n        if getattr(conn, \"sock\", None):\n            # In Python 3 socket.py will catch EAGAIN and return None when you\n            # try and read into the file pointer created by http.client, which\n            # instead raises a BadStatusLine exception. Instead of catching\n            # the exception and assuming all BadStatusLine exceptions are read\n            # timeouts, check for a zero timeout before making the request.\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, \"Read timed out. (read timeout=%s)\" % read_timeout\n                )\n            if read_timeout is Timeout.DEFAULT_TIMEOUT:\n                conn.sock.settimeout(socket.getdefaulttimeout())\n            else:  # None or a value\n                conn.sock.settimeout(read_timeout)\n    \n        # Receive the response from the server\n        try:\n            try:\n                # Python 2.7, use buffering of HTTP responses\n                httplib_response = conn.getresponse(buffering=True)\n            except TypeError:\n                # Python 3\n                try:\n                    httplib_response = conn.getresponse()\n                except BaseException as e:\n                    # Remove the TypeError from the exception chain in\n                    # Python 3 (including for exceptions like SystemExit).\n                    # Otherwise it looks like a bug in the code.\n>                   six.raise_from(e, None)\n\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\connectionpool.py:468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\connectionpool.py:463: in _make_request\n    httplib_response = conn.getresponse()\nC:\\Program Files\\Python312\\Lib\\http\\client.py:1428: in getresponse\n    response.begin()\nC:\\Program Files\\Python312\\Lib\\http\\client.py:331: in begin\n    version, status, reason = self._read_status()\nC:\\Program Files\\Python312\\Lib\\http\\client.py:292: in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <socket.SocketIO object at 0x000001E782055030>\nb = <memory at 0x000001E781F76200>\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n    \n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        \"\"\"\n        self._checkClosed()\n        self._checkReadable()\n        if self._timeout_occurred:\n            raise OSError(\"cannot read from timed out object\")\n        while True:\n            try:\n>               return self._sock.recv_into(b)\nE               TimeoutError: timed out\n\nC:\\Program Files\\Python312\\Lib\\socket.py:707: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\n    def setup_function():\n        global driver\n        service = Service(GeckoDriverManager().install())\n>       driver = webdriver.Firefox(service=service)\n\ntest_abc.py:11: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\selenium\\webdriver\\firefox\\webdriver.py:71: in __init__\n    super().__init__(command_executor=executor, options=options)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:250: in __init__\n    self.start_session(capabilities)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:342: in start_session\n    response = self.execute(Command.NEW_SESSION, caps)[\"value\"]\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:427: in execute\n    response = self.command_executor.execute(driver_command, params)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py:404: in execute\n    return self._request(command_info[0], url, body=data)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py:428: in _request\n    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\request.py:81: in request\n    return self.request_encode_body(\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\request.py:173: in request_encode_body\n    return self.urlopen(method, url, **extra_kw)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\poolmanager.py:376: in urlopen\n    response = conn.urlopen(method, u.request_uri, **kw)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\connectionpool.py:802: in urlopen\n    retries = retries.increment(\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\util\\retry.py:552: in increment\n    raise six.reraise(type(error), error, _stacktrace)\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\packages\\six.py:770: in reraise\n    raise value\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\connectionpool.py:716: in urlopen\n    httplib_response = self._make_request(\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\connectionpool.py:470: in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001E782054E60>\nerr = TimeoutError('timed out'), url = '/session', timeout_value = 120\n\n    def _raise_timeout(self, err, url, timeout_value):\n        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"\n    \n        if isinstance(err, SocketTimeout):\n>           raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\nE           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=60095): Read timed out. (read timeout=120)\n\n..\\..\\..\\AppData\\Roaming\\Python\\Python312\\site-packages\\urllib3\\connectionpool.py:358: ReadTimeoutError"}, "parameters": [{"name": "username", "value": "'engribadkhan96@gmail.com'"}, {"name": "password", "value": "'Engr@1122'"}], "start": 1745499081268, "stop": 1745499081269, "uuid": "3ac64b2d-8cd5-4879-85eb-764bef826b63", "historyId": "aa055fe32355e8bd257b86c483e4c7a5", "testCaseId": "e901964f6f82de52b9ca29ce9dddeb08", "fullName": "test_abc#test_login", "labels": [{"name": "suite", "value": "test_abc"}, {"name": "host", "value": "ENGRKHAN"}, {"name": "thread", "value": "9060-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_abc"}]}